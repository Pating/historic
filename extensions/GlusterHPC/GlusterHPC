#!/usr/bin/python
##
## Copyright (C) 2006 Z RESEARCH Inc. <http://www.zresearch.com>
##  
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##  
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##  
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
##  
##

import getopt, sys, os, ConfigParser
from Gluster.gpartdump import *
from Gluster import GExtension, GIPv4, GIP
from Gluster.GFrontEnd import dialog

dlg = dialog.Dialog ()
reg = ConfigParser.ConfigParser ()
port_base = 13370
number_of_nodes = 0
clientinfo = '/var/gluster/clientinfo'
failed_nodes = []
success_nodes = []

def get_hostname (s=''):
    hname = reg.get ('global', 'hostname')
    return hname + s

def get_domainname ():
    return reg.get ('global', 'domain')

def no_hosts ():
    global number_of_nodes
    
    nodes = os.popen ("gping -i /tmp/ghpc_selected_dst_nodes").readlines ()

    nodes = map (lambda x: x.strip ().split (':')[0], nodes)
    number_of_nodes = len (nodes)
    return (number_of_nodes, nodes)

def get_slaves (node):
    while True:
        num_hosts = 0
        (num_hosts, nodes_on) = no_hosts ()
        choices = []
        if len (nodes_on):
            choices = nodes_on
        if node in choices:
            choices.remove (node)
            num_hosts -= 1
        if choices == []:
            choices = ["<no clients>"]

        (ret, sel) = dlg.menu ("The following nodes will be imaged...\n\nKeep pressing 'Refresh' till you have all the required nodes here (totally %d nodes listed)\n" % int (num_hosts),
                               choices=map (lambda x: (x, ''), choices),
                               extra_button=True,
                               extra_label='Back',
                               cancel='Refresh',
                               defaultno=True,
                               title='[ Active Nodes ]')
        if ret == 4:
            return None 
        if ret != 0:
            continue        
        if num_hosts == 0:
            dlg.msgbox ("No client nodes detected\n",
                        title="[ Error ]")
            continue
        return choices
    return
    
def source_config (node):
    os.system ("cat /stage3/init.tgz | ssh %s client-gex" % node)
    os.system ("cat /stage3/gutils.tgz | ssh %s client-gex" % node)
    os.system ("cat /stage3/fs-utils.tgz | ssh %s client-gex" % node)
    if os.system ("ssh -t %s 'gprobe | gpart-sel -o /tmp/ghpc.spec -c /tmp/ghpc_tar_cmds -m /tmp/ghpc_approx_max' 2>>/var/log/proglog" % node) != 0:
        return 1
    else:
        return 0


def make_slaves (slave_list):
    session_hosts = file ('/tmp/session_hosts','w')
    for slave in slave_list:
        session_hosts.write ("%s\n" % slave)
    session_hosts.close ()
    os.system ("gping -p 1332 -i /tmp/ghosts/known_ip -m up >/dev/null 2>&1")
    os.system ("gping -p 1332 -i /tmp/session_hosts -m slave >/dev/null 2>&1")
    os.system ("sleep 1")
    return
   

def source_action (node):
    partlist = gdump_partlist (read_gdump (os.popen ("ssh %s 'cat /tmp/ghpc.spec' 2>>/var/log/proglog" % node)))
    parts = partlist.keys ()
    parts = filter ((lambda x:
                     partlist[x]['FS'] != 'linux-swap' and partlist[x]['XFER'] == 'Y'),
                    parts)
    no_parts = len (parts)
    min_clients = os.popen ('gping -p 1332 -i /tmp/session_hosts | grep slave | wc -l').readline ().strip ()
    cmd_file = os.popen ("ssh %s dd of=/tmp/ghpc_src_cmds 2>>/var/log/proglog" % node, "w")
    for i in range (no_parts):
        cmd_file.write ('udp-sender --portbase %d --nokbd --min-clients %s --max-wait 1200 --interface %s 2>/dev/null\n' %
                    (port_base + 2*i, min_clients, reg.get ('global', 'interface')))
    cmd_file.flush ()
    cmd_file.close ()

    os.system ("ssh -t %s 'gstream -f -i /tmp/ghpc_tar_cmds -o /tmp/ghpc_src_cmds -m `cat /tmp/ghpc_approx_max`'" % node)
    return

def dest_config (node):

    dlg.infobox ("Installing Gluster extensions to client nodes")
    # Send all the gex packages to clients
    os.system ("ghpc_send >>/var/log/proglog 2>&1")
    
    partlist = gdump_partlist (read_gdump (os.popen ('ssh %s cat /tmp/ghpc.spec 2>>/var/log/proglog' % node)))
    parts = partlist.keys ()
    parts = filter ((lambda x:
                     partlist[x]['FS'] != 'linux-swap' and partlist[x]['XFER'] == 'Y'),
                    parts)
    no_parts = len (parts)
    cmd_file = os.popen ('ssh %s dd of=/tmp/ghpc_dest_cmds 2>>/var/log/proglog' % node, "w")
    for i in range (no_parts):
        cmd_file.write ('udp-receiver --nokbd --portbase %d\n' %
                    (port_base + 2*i))
    cmd_file.flush ()
    cmd_file.close ()

    return

def hpc_action (node):
    # TODO: Give a hook to user inbetween
    os.system ("ssh %s 'gmeta-installer --auto --input /tmp/ghpc.spec -c /tmp/ghpc_dest_cmds' >>/var/log/proglog 2>&1" % node)
    if get_hostname ('1') != node:
        os.system ("rm -rf /tmp/gmi")
        os.system ("scp -r %s:/tmp/gmi /tmp" % node)
    os.system ("chmod +x /tmp/gmi/*")
    os.system ("sed -i 's,^#\\(.\\)/bin/sh,#\\1/usr/bin/gdscript /bin/sh,' /tmp/gmi/* 2>>/var/log/proglog")

    dlg.infobox ("Partitioning and preparing filesystems on client nodes.")
    if os.system ("/tmp/gmi/00-partition.sh >>/var/log/proglog 2>&1"):
        dlg.msgbox ("Problems during installation\nExiting\n",
                    title='[ Error ]')
        return

    dlg.infobox ("Mounting initialized partitions\n")
    if os.system ("/tmp/gmi/01-mount.sh >>/var/log/proglog 2>&1"):
        dlg.msgbox ("Problems during installation\nExiting\n",
                    title='[ Error ]')
        return

    dlg.infobox ("Preparing client nodes for image transfer\n")
    if os.system ("/tmp/gmi/02-untar.sh >>/var/log/proglog 2>&1"):
        dlg.msgbox ("Problems during installation\nExiting\n",
                    title='[ Error ]')
        return

    source_action (node)

    dlg.infobox ("Updating '/etc/fstab' in client nodes\n")    
    if os.system ("/tmp/gmi/03-fstab.sh >>/var/log/proglog 2>&1"):
        dlg.msgbox ("Problems during installation\nExiting\n",
                    title='[ Error ]')
        return

    dlg.infobox ("Installing boot manager in client nodes\n")
    os.system ("sleep 7");
    if os.system ("/tmp/gmi/04-bootloader.sh >>/var/log/proglog 2>&1"):
        dlg.msgbox ("Problems during installation\nExiting\n",
                    title='[ Error ]')
        return


    dlg.infobox ("Performing postinstall in client nodes\n")
    if os.system ("/tmp/gmi/05-postinstall.sh >>/var/log/proglog 2>&1"):
        dlg.msgbox ("Problems during installation\nExiting\n",
                    title='[ Error ]')
        return

    dlg.infobox ("Unmounting partitions\n")
    if os.system ("/tmp/gmi/06-umount.sh >>/var/log/proglog 2>&1"):
        dlg.msgbox ("Problems during installation\nExiting\n",
                    title='[ Error ]')
        return
    return

def get_dst_nodes (dst_nodes):
    # write the name of the nodes in the dst_nodes properly
    ipobj = GIPv4.IPv4 (reg.get ('global', 'startip'),
                        reg.get ('global', 'netmask'))
    offset = int (ipobj.hostpart) - 1

    fd = file ('/tmp/ghpc_selected_dst_nodes', 'w')
    nodes = dst_nodes.split (',')
    if nodes[-1] == '':
        dlg.msgbox ("Enter a valid entry. Check the examples given\n",
                    title="[ Error ]")
        fd.close ()
        return 1
    for i in nodes:
        x = i.split ('-')
        if len (x) == 1:
            fd.write ("%s\n" % (ipobj [ offset + int (x[0]) ]))
        elif len (x) == 2:
            if int (x[0]) < int (x[1]):
                for a in range (int (x[0]), int (x[1]) + 1):
                    fd.write ("%s\n" % (ipobj[a + offset]))
            else:
                dlg.msgbox ("Enter a valid entry. Check the examples given\n",
                            title="[ Error ]")
                fd.close ()
                return 1
        else:
            dlg.msgbox ("Enter a valid entry. Check the examples given\n",
                        title="[ Error ]")
            fd.close ()
            return 1
    fd.close ()
    return 0

def get_node_name ():
    sel = None
    while True:
        (ret, sel) = dlg.inputbox ("Select the source and destination for imaging\n\n" + 
        "Examples:\n1:2-64       -- Image node2 to node64 from node1 (or master-node)\n" +
                   "4:5,10,20-29 -- Image node5,node10 and node20 to node29 from node4\n\n" +
                   "NOTE: If you leave the inputbox empty, it specifies not to do any imaging, but only configure all the cluster nodes\n",
                                   title="[ Image Selector ]",
                                   ok_label = ' Select ',
                                   cancel=' Back ',
                                   init='1:2-%s' % reg.get ('global', 'totalnodes'))
        # Validate and write the session hosts file
        
        if ret != 0:
            return (ret, None)
        if sel == '':
            return (0, None)
        nodes = sel.strip ().split (':')
        if len (nodes) > 2 or nodes[1] == '':
            dlg.msgbox ("Enter a valid entry. Check the examples given\n",
                        title="[ Error ]")
            continue
        if os.system ("gping %s" % get_hostname (nodes[0])) != 0:
            dlg.msgbox ("%s is not reachable" % get_hostname (nodes[0]),
                        title="[ Error ]")
            continue
        if get_dst_nodes (nodes[1]) == 1:
            continue
        sel = get_hostname (nodes[0])
        break
    return (ret, sel)

def register_client ():
    ret = GExtension.run ('client-reg')
    reg.read (clientinfo)
    GExtension.run ('bootp-manager', '--auto 2>>/var/log/proglog')
    return ret

def mac_collector ():
    ret = GExtension.run ('mac-collector')
    if ret == 0:
        os.system ('ghosts --update-known-hosts')
    return ret

def state_sel ():
    return os.system ('gstate-sel')

def collect_status ():
    global failed_nodes
    global success_nodes

    os.system ("gping -i /tmp/session_hosts >/tmp/ghpc_stats")

    nodes = file ('/tmp/ghpc_stats', 'r').readlines ()
    nodes = map (lambda x:x.split (':'), nodes)
    for node in nodes:
        if node[1].strip () != 'success':
            failed_nodes.append (node[0])
        else:
            success_nodes.append (node[0])

    all_nodes = file ('/tmp/session_hosts', 'r').readlines ()
    report_file = file ('/tmp/ghpc_stats', 'a')

    for node in map (string.strip, all_nodes):
        if node in map (lambda x: x[0], nodes):
            continue
        report_file.write ("%s: Unreachable\n" % node)
    report_file.close ()
    return

def display_status ():
    global failed_nodes
    global success_nodes
    
    if dlg.yesno ("Installation Report : \n" +
                  "%d nodes successfully installed\n" % len (success_nodes) +
                  "%d nodes failed\n" % len (failed_nodes),
                  title='[ Report ]',
                  yes_label='Ok',
                  no_label='Details'):
        dlg.textbox (filename='/tmp/ghpc_stats',
                     width=50,
                     height=16)
    return 

def imaging ():
    (ret, hname) = get_node_name ()
    if ret == 0:
        if not hname:
            return 0
        selected_slaves = get_slaves (hname)
        if not selected_slaves:
            return 1
        make_slaves (selected_slaves)
        if source_config (hname) != 0:
            return 1
        dest_config (hname)
        hpc_action (hname)
        collect_status ()
    else:
        return 1

    return 0


def main ():
    global number_of_nodes
    (opt, args) = getopt.getopt (sys.argv[1:], "c",
                                 ["client"])
    for (o, val) in opt:
        if o == '-c' or o == '--client':
            return

    os.system ('> /var/log/proglog; killall tail')

    fn_idx = 0
    function = [state_sel, register_client, mac_collector, imaging]
    hname = ''
    # The loop is used for 'back' option ;)
    while True:
        ret = function[fn_idx] ()
        if ret == 0:
            fn_idx += 1
        else:
            if fn_idx != 0:
                fn_idx -= 1
            else:
                if dlg.yesno ('Are you sure of exiting GlusterHPC?'):
                    continue
                return 0
        if fn_idx == len (function):
            break

    # Now the imaging is done. Install and configure the HPC apps.
    
    all_slaves = map (string.strip, file ('/tmp/ghosts/known_ip').readlines ())
    make_slaves (all_slaves)

    os.system ("ghpc_send >>/var/log/proglog 2>&1")
    os.system ("STDIN=/dev/null gcsh gmount")
    os.system ("gmount")

    ## Adding additional interface configuration
    os.system ("gex --install /stage3/iface-cfg.gex")

    ret = os.system ("gpkg-sel")

    os.system ("STDIN=/dev/null gcsh gumount")
    os.system ("gumount")
    
    if ret == 0:
        display_status ()
    return

main ()
