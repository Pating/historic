#!/usr/bin/python
##
## Copyright (C) 2006 Z RESEARCH Inc. <http://www.zresearch.com>
##  
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##  
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##  
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
##  
##

from Gluster.GFrontEnd import dialog
from Gluster import GIP, GIPv4
import os, sys, re, string, ConfigParser

clientinfo = "/var/gluster/clientinfo"

cfg = ConfigParser.ConfigParser ()
cfg.read (clientinfo)

d = dialog.Dialog ();

def is_valid_ip (ip):
    try:
        i = GIPv4.IPv4 (ip.strip ('/'))
    except:
        return False
    return True

def is_valid_number (num):
    try:
        n = string.atoi (num)
        return True
    except:
        return False
    return True

def is_valid_netmask (nmask):
    try:
        i = GIPv4.IPv4 ('1.1.1.1', nmask)
    except:
        return False
    return True

def is_valid_hostname (hname):
    c = re.compile ("^[a-zA-Z][a-zA-Z0-9_\-]*$")
    matches = c.findall (hname)
    if len (matches) != 1 or matches[0] != hname:
        return False
    return True

def is_valid_domain (domain):
    c = re.compile ("^[a-zA-Z][a-zA-Z0-9_\-\.]*$")
    matches = c.findall (hname)
    if len (matches) != 1 or matches[0] != hname:
        return False
    return True

cluster_config = {
    'startip': ['192.168.1.1',
                 'Starting IP of the cluster (master node IP)',
                is_valid_ip],
    'totalnodes': ['64',
                   'total number of nodes in the cluster (including master node)',
                   is_valid_number],
    'netmask' : ['255.255.255.0',
                 'Subnet mask of the cluster',
                 is_valid_netmask],
    'hostname': [ 'node',
                  'hostname prefix for all nodes. e.g if the hostname prefix is `box\', then nodes will be named `box1\' `box2\' etc',
                  is_valid_hostname],
    'domain': [ 'gluster.org',
                'DNS domain name of the cluster',
                is_valid_domain],
    'bootp': [ 'yes',
               'should BOOTP be turned on?' ],
    'interface': [ 'eth0', 'client side interface' ]
    }


def sync ():
    fp = open (clientinfo, "w")
    cfg.write (fp)
    fp.close ()

def ask_and_set (var):
    (ret, input) = d.inputbox (cluster_config[var][1],
                               init=cfg.get ('global', var))
    if ret != 0:
        return

    if not cluster_config[var][2] (input):
        d.msgbox ('Invalid input "%s"' % input.strip ())
        return
    cfg.set ('global', var, input)
    sync ()
    return


oldip = False
oldiface = False

if not cfg.has_section ('global'):
    cfg.add_section ('global')
    for member in cluster_config.keys ():
        cfg.set ('global', member, cluster_config[member][0])
    sync ()
else:
    oldip = cfg.get ('global', 'startip')
    oldiface = cfg.get ('global', 'interface')

while True:
    (ret, choice) = d.menu ("configure cluster details",
                        choices=map (lambda x: (x, cfg.get ('global', x)),
                                     ['interface',
                                      'startip',
                                      'netmask',
                                      'totalnodes',
                                      'hostname',
                                      'domain']),
                            cancel="done",
                            extra_button=True,
                            ok_label="edit",
                            extra_label="back")

    if ret == 4:
        sys.exit (1)
        break
    
    if ret != 0:
        ipobj = GIPv4.IPv4 (cfg.get ('global', 'startip'),
                    cfg.get ('global', 'netmask'))
        netsize = pow (2, 32 - ipobj.maskbits)
        totalnodes = string.atoi (cfg.get ('global', 'totalnodes'))
        if totalnodes < 2:
            d.msgbox ('Total nodes is invalid. You need atleast 2 hosts')
            continue
        if totalnodes > netsize:
            d.msgbox ('The netmask you specified (%s) accomodates %d hosts, while your total nodes is %d' % (cfg.get ('global', 'netmask'), netsize, totalnodes),
                        title='[ Error ]')
            continue
        break
            
    if choice == 'startip':
        ask_and_set ('startip')

    if choice == 'domain':
        ask_and_set ('domain')

    if choice == 'hostname':
        ask_and_set ('hostname')

    if choice == 'netmask':
        ask_and_set ('netmask')

    if choice == 'totalnodes':
        ask_and_set ('totalnodes')
        
    if choice == 'bootp':
        no = d.yesno ("want bootp?")
        if no:
            cfg.set ('global', 'bootp', 'no')
        else:
            cfg.set ('global', 'bootp', 'yes')
        sync ()
        
    if choice == 'interface':
        (ret, iface) = d.menu (cluster_config['interface'][1],
                               choices=map (lambda x: (x, GIP.get_iface_status (x)),
                                            GIP.get_ifaces_list ()),
                               default_item=cfg.get ('global', 'interface'))
        if ret != 0:
            continue
        cfg.set ('global', 'interface', iface)
        sync ()

ipobj = GIPv4.IPv4 (cfg.get ('global', 'startip'),
                    cfg.get ('global', 'netmask'))

offset = int (ipobj.hostpart) - 1
master_node = cfg.get ('global', 'startip')
os.system ("ifconfig %s %s netmask %s" %
           (cfg.get ('global', 'interface'),
            cfg.get ('global', 'startip'),
            cfg.get ('global', 'netmask')))

hosts_file = file ('/tftpboot/hosts', "w")
hosts_file.write ("\n127.0.0.1\tlocalhost.localdomain\tlocalhost\n\n")
hostname = cfg.get ('global', 'hostname')
domain = cfg.get ('global', 'domain')
for index in range (string.atoi (cfg.get ('global', 'totalnodes'))):
    i_idx = index + 1
    i_ip = ipobj[i_idx + offset].getStrings ()[0]
    hosts_file.write ("%s\t%s%d.%s\t%s%d\n" % (i_ip,
                                               hostname,
                                               i_idx,
                                               domain,
                                               hostname,
                                               i_idx))
hosts_file.write ('%s\tmaster-node.%s\tmaster-node\n' % (master_node,
                                                       domain))
hosts_file.close ()
os.system ("cp /tftpboot/hosts /etc/hosts")
rsa_key = file ('/etc/ssh/ssh_host_rsa_key.pub').readline ()
known_hosts_fd = file ('/.ssh/known_hosts', "w")
known_hosts_fd.write ('%s* %s' % (hostname, rsa_key))
known_hosts_fd.write ('%s* %s' % ('master-node', rsa_key))
known_hosts_fd.write ('%s*.%s %s' % (hostname, domain, rsa_key))
known_hosts_fd.write ('%s*.%s %s' % ('master-node', domain, rsa_key))
known_hosts_fd.close ()
os.system ('tar -C /etc/ssh -cf /tftpboot/etc-ssh.tar .')
os.system ('tar -C /.ssh -cf /tftpboot/dot-ssh.tar .')

